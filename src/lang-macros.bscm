;; Copyright 2014,2015 - William Emerison Six
;;  All rights reserved
;;  Distributed under LGPL 2.1 or Apache 2.0

;; at-compile-time
;;  Evaluate the form in the compiler's address space.  When the program is
;;  executed, form will not be evaluated.

{define-macro at-compile-time
  [|form|
   (eval form)
   `(quote noop)]}

;; at-both-times
;;  Evaluate the form in the compiler's address space, and also when the
;;  resulting program is executed.

{define-macro at-both-times
  [|form|
   (eval form)
   form]}

;;  if
;;    A Smalltalk-like if.
;;    Sample use:
;;      (if #t
;;        [4]
;;        [5])
{at-both-times
 {define-macro if
   [|pred ifTrue ifFalse|
    ;; (expression? [5]) => true
    ;; (expression? [(pp 4) 6]) => false
    {let ((expression?
	   [|lst| (equal? 3 (length lst))]))
      `(##if ,pred
	   ,(##if (expression? ifTrue)
		(caddr ifTrue)
		`(begin ,@(cddr ifTrue)))
	   ,(##if (expression? ifFalse)
		(caddr ifFalse)
		`(begin ,@(cddr ifFalse))))}]}}



 ;; with-test
;;   Collocates a definiton with a test.  The test is run at compile-time
;;   only.
{define-macro with-test
  [|definition test|
   (eval
    `(begin
       ,definition
       (if ,test
	   ['no-op]
	   [{pp "Test Failed"}
	    {pp (quote ,test)}
	    {pp (quote ,definition)}
	    {error "Test Failed"}])))
   ;;the actual macro expansion is just the definition
   definition]}


;; with-tests
;;   Collocates a definition with a collection of tests.  Tests are
;;   run sequentially, and are expected to return true or false
{define-macro with-tests
  [|definition #!rest test|
   `{with-test ,definition (and ,@test)}]}


;; when
;;   when the bool value is non-false, return the value of statement.
;;   when the bool value is false, return false
;; TODO - statement needs to be wrapped in a begin
{with-tests
 {define-macro when
   [|bool statement|
    `(if ,bool
	      [,statement]
	      [#f])]}
 (equal? (when 5 3) 3)
 (equal? (when #f 3) #f)}

;; aif
;;   anaphoric-if evaluates bool, binds it to the variable "it",
;;   which is accessible in body.
{with-tests
 {define-macro aif
   [|bool body|
    `(let ((it ,bool))
       (when it
	     ,body))]}
 (equal? (aif (+ 5 10) (* 2 it))
	 30)
 (equal? (aif #f (* 2 it))
	 #f)}

;; with-gensyms
;;   Utility for macros to minimize explicit use of gensym.
;;   Gensym creates a symbol at compile time which is guaranteed
;;   to be unique.  Macros which intentionally capture variables,
;;   such as aif, are the anomaly.
;;   Usually, variables local to a macro should not clash
;;   with variables local to the macro caller.
;;
{at-both-times
 {define-macro with-gensyms
   [|symbols #!rest body|
    `{let ,(map [|symbol| `(,symbol {gensym})]
		symbols)
       ,@body}]}}

;; for testing purposes, create a bogus version of aif
;; which uses with-gensyms to intentionally *not* capture
;; 'it'
{at-compile-time
 {define-macro non-working-aif
   [|bool body|
    {with-gensyms
     (it)
     `(let ((,it ,bool))
	{when ,it
	      ,body})}]}}
{with-tests
 'ignore ;; testing with-gensyms, which has already been defined
 (equal? {let ((it 0))
	   {aif (+ 5 10) (* 2 it)}}
	 ;; in the true aif, 'it' is captured and set, hence it
	 ;; is not 0
	 30)
 (equal? {let ((it 0))
	   {non-working-aif (+ 5 10) it}}
	 ;; when using with-gensyms, it is not captured, hence
	 ;; it is 0
	 0)}




;; setf!
;;   Sets a value using its getter, as done in Common Lisp.
;;
;;   Implementation inspired by http://okmij.org/ftp/Scheme/setf.txt

;; this dummy structure is used in a test
{at-compile-time
 {define-structure foo bar baz}}
{with-tests
 {define-macro setf!
   [|get-expression val|
    (if (not (pair? get-expression))
	[`{set! ,get-expression ,val}]
	[{case (car get-expression)
	   ((car) `{set-car! ,@(cdr get-expression) ,val})
	   ((cdr) `{set-cdr! ,@(cdr get-expression) ,val})
	   ((cadr) `{setf! (car (cdr ,@(cdr get-expression))) ,val})
	   ((cddr) `{setf! (cdr (cdr ,@(cdr get-expression))) ,val})
	   ;; TODO - handle other atypical cases
	   (else `(,(string->symbol (string-append (symbol->string (car get-expression))
						   "-set!"))
		   ,@(cdr get-expression)
		   ,val))}])]}
 ;; test variable
 {let ((a 5))
   {setf! a 10}
   (equal? a 10)}
 {begin
   {let ((a (make-foo 1 2)))
     {setf! (foo-bar a) 10}
     (equal? (make-foo 10 2)
 	     a)}}
 ;; test car
 {let ((a (list 1 2)))
   {setf! (car a) 10}
   (equal? a '(10 2))}
 ;; test cdr
 {let ((a (list 1 2)))
   {setf! (cdr a) (list 10)}
   (equal? a '(1 10))}
 ;; test cadr
 {let ((a (list (list 1 2) (list 3 4))))
   {setf! (cadr a) 10}
   (equal? a '((1 2) 10))}
 ;; test cddr
 {let ((a (list (list 1 2) (list 3 4))))
   {setf! (cddr a) (list 10)}
   (equal? a '((1 2) (3 4) 10))}

 }

